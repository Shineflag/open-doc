

**译者： coderbee (wen866595@163.com)，博客： [码蜂笔记](http://coderbee.net)   
转载请注明出处**

翻译自：
<https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format>



# Redis RDB 文件格式
`Redis *.rdb` 文件是一个内存内存储的二进制表示法。这个二进制文件足以完全恢复 Redis 的状态。

rdb 文件格式为快速读和写优化。LZF 压缩可以用来减少文件大小。通常，对象前面有它们的长度，这样，在读取对象之前，你可以准确地分配内存大小。


为快速读/写优化意味着磁盘上的格式应该尽可能接近于在内存里的表示法。这种方式正是 rdb 文件采用的。
导致的结果是，在不了解 Redis 在内存里表示数据的数据结构的情况下，你没法解析 rdb 文件。


## 解析RDB的高层算法
在高层层面看，RDB 文件有下面的格式：
<pre><code>
----------------------------# RDB 是一个二进制文件。文件里没有新行或空格。
52 45 44 49 53              # 魔术字符串 "REDIS"
30 30 30 33                 # RDB 版本号，高位优先。在这种情况下，版本是 0003 = 3
----------------------------
FE 00                       # FE = code 指出数据库选择器. 数据库号 = 00
----------------------------# 键值对开始
FD $unsigned int            # FD 指出 "有效期限时间是秒为单位". 在这之后，读取 4 字节无符号整数作为有效期限时间。
$value-type                 # 1 字节标记指出值的类型 － set，map，sorted set 等。
$string-encoded-key         # 键，编码为一个 redis 字符串。
$encoded-value              # 值，编码取决于 $value-type.
----------------------------
FC $unsigned long           # FC 指出 "有效期限时间是豪秒为单位". 在这之后，读取 8 字节无符号长整数作为有效期限时间。
$value-type                 # 1 字节标记指出值的类型 － set，map，sorted set 等。
$string-encoded-key         # 键，编码为一个redis字符串。
$encoded-value              # 值，编码取决于 $value-type.
----------------------------
$value-type                 # 这个键值对没有有效期限。$value_type 保证 != to FD, FC, FE and FF
$string-encoded-key
$encoded-value
----------------------------
FE $length-encoding         # 前一个数据库结束，下一个数据库开始。数据库号用长度编码读取。
----------------------------
...                         # 这个数据库的键值对，另外的数据库。
FF                          ## RDB 文件结束指示器
8 byte checksum             ## 整个文件的 CRC32 校验和。
</code></pre>


### 魔术数
文件开始于魔术字符串 `REDIS`。这是一个快速明智的检查是否正在处理一个 redis rdb 文件。   
`52 45 44 49 53 # "REDIS" `


### RDB 版本号
接下来 `4` 个字节存储了rdb格式的版本号。这 `4` 个字节解释为 ascii 字符，然后使用字符串到整数的转换法转换为一个整数。   
`00 00 00 03 # Version = 3`


### 数据库选择器
一个 Redis 实例可以有多个数据库。   
单一字节 `0xFE` 标记数据库选择器的开始。在这个字节之后，一个可变长度的字段指出数据库序号。   
见“长度编码”章节来了解如何读取数据库序号。


### 键值对
在数据库选择器之后，文件包含了一序列的键值对。

每个键值对有 4 部分：
>  1.  键保存期限时间戳。这是可选的。
>  2.  一个字节标记值的类型。
>  3.  键编码为 Redis 字符串。见“Redis 字符串编码”。
>  4.  值根据值类型进行编码。见“Redis 值编码”。


#### 键保存期限时间戳
这个区块开始于一字节标记。值 `FD` 指出保存期限是以秒为单位指定。值 `FC` 指出有效期限是以毫秒为单位指定。

如果时间指定为毫秒，接下来 `8` 个字节表示 unix 时间。这个数字是 unix 时间戳，精确到秒或毫秒，表示这个键的有效期限。

数字如何编码见“Redis 长度编码”章节。

在导入过程中，已经过期的键将必须丢弃。


#### 值类型
一个字节标记指示用于保存值的编码。

>  1.  `0` ＝ “String 编码”
>  2.  `1` ＝ “ List 编码”
>  3.  `2` ＝ “Set 编码”
>  4.  `3` ＝ “Sorted Set 编码”
>  5.  `4` ＝ “Hash 编码”
>  6.  `9` ＝ “Zipmap 编码”
>  7.  `10` ＝ “Ziplist 编码”
>  8.  `11` ＝ “IntSet 编码”
>  9.  `12` ＝ “以 Ziplist 编码的 Sorted Set”
>  10.  `13` ＝ “以 Ziplist 编码的 Hashmap” （在 rdb 版本 4 中引入）


#### 键
键简单地编码为 Redis 字符串。见“字符串编码”章节了解键如何被编码。


#### 值
值的编码取决于值类型标记。

* 当值类型等于 `0`，值是简单字符串。
* 当值类型是 `9`， `10`， `11` 或 `12` 中的一个，值被包装为字符串。读取字符串后，它必须进一步解析。
* 当值类型是 `1`，`2`，`3` 或 `4` 中的一个，值是一序列字符串。这个序列字符串用于构造 list，set，sorted set 或 hashmap。


## 长度编码
长度编码用于存储流中接下来对象的长度。长度编码是一个可变字节编码，为尽可能少用字节而设计。

这是长度编码如何工作：
> 1.  从流中读取一个字节，最高 `2` bit 被读取。
> 2.  如果开始 bit 是 `00` ，接下来 `6` bit 表示长度。
> 3.  如果开始 bit 是 `01`，从流再读取额外一个字节。这组合的的 `14` bit 表示长度。
> 4.  如果开始 bit 是 `10`，那么剩余的 `6`bit 丢弃，从流中读取额外的 `4` 字节，这 `4` 个字节表示长度。
> 5.  如果开始 bit 是 `11`，那么接下来的对象是以特殊格式编码的。剩余 `6` bit 指示格式。这种编码通常用于把数字作为字符串存储或存储编码后的字符串。见字符串编码。

作为这种编码的结果：
>  1.  数字 `[0 - 63]` 可以在 `1` 个字节里存储
>  2.  数字 `[0 - 16383]` 可以在 `2` 个字节里存储
>  3.  数字 `[0 - (2^32 - 1)]` 可以在 `4` 个字节里存储


## 字符串编码
Redis 字符串是二进制安全的－－这意味着你可以在这里存储任何东西。它们没有任何特殊的字符串结束记号。
最好认为 Redis 字符串是一个字节数组。

Redis 里有三种类型的字符串：   
> 1.  长度前缀字符串。
> 2.  一个 `8`，`16` 或 `32` bit 整数。
> 3.  LZF 压缩的字符串。


#### 长度前缀字符串
长度前置字符串是很简单的。字符串字节的长度首先编码为“长度编码”，在这之后存储字符串的原始字节。


#### 整数作为字符串
首先读取“长度编码”块，特别是第一个 `2` bit 是 `11`。在这种情况下，读取剩余的 `6` bit。如果这 `6` bit 的值是：
> 1.  `0` 表示接下来是 `8` bit 整数
> 2.  `1` 表示接下来是 `16` bit 整数
> 3.  `2` 表示接下来是 `32` bit 整数

这些整数都是以 little endian 格式编码的。

#### 压缩字符串
首先读取“长度编码”，特别是第一个 `2` bit 是 `11`. 在这种情况下，读取剩余 `6` bit。如果这 `6` bit值是 `3`，它表示接下来是一个压缩字符串。

压缩字符串按如下读取：
> 1.  从流中读取压缩后的长度 `clen`，按“长度编码”。
> 2.  从流中读取未压缩长度，按“长度编码”。
> 3.  接下来从流中读取 `clen` 个字节。
> 4.  最后，这些字节按 LZF 算法解压。


## List 编码
一个 Redis list 表示为一序列字符串。

> 1.  首先，从流中读取 list 的大小： `size`，按“长度编码”。
> 2.  然后，`size` 个字符串从流中读取，按“字符串编码”。
> 3.  使用这些字符串重新构建 list。


## Set 编码
Set 编码与 list 完全类似。


## Sorted Set 编码
> 1.  首先，从流中读取 sorted set 大小 `size`，按“长度编码”
> 2.  先后读取两个字符串作为 set 的元素和它的分值，作为一个元组。
> 3.  一共读取 `size` 个上面的元组作为 sorted set 集合。


## Hash 编码
> 1.  首先，从流中读取hash大小 `size`，按“长度编码”。
> 2.  下一步，从流中读取 `2 * size` 个字符串，按“字符串编码”。
> 3.  交替的字符串是键和值。
> 4.  例如，`2 us washington india delhi` 表示map `{"us" => "washington", "india" => "dlhi"}`。


## Zipmap 编码
*注意：Zipmap 编码从 Redis 2.6开始已弃用。小的的 hashmap 编码为 ziplist。*

Zipmap 是一个被序列化为一个字符串的 hashmap。本质上，键值对按顺序存储。在这种结构里查找一个键的复杂度是 `O(N)`。
当键值对数量很少时，这个结构用于替代 dictionary。

为解析 zipmap，首先用“字符串编码”从流读取一个字符串。这个字符串包装了 zipmap。字符串的内容表示了 zipmap。

字符串里的 zipmap 结构如下： `<zmlen><len>"foo"<len><free>"bar"<len>"hello"<len><free>"world"<zmend>`

1.  `zmlen` : `1` 字节长，保存 zipmap 的大小. 如果大于等于 `254`，值不使用。将需要迭代整个 zipmap 来找出长度。
2.  `len` : 后续字符串的长度，可以是键或值的。这个长度存储为 `1` 个或 `5` 个字节（与上面描述的“长度编码”不同）。
            如果第一个字节位于 `0` 到 `252`，那么它是 zipmap 的长度。如果第一个字节是 `253`，读取下 `4` 个字节作为无符号整数来表示 zipmap 的长度。
            `254` 和 `255` 对这个字段是非法的。
3.  `free` : 总是 `1` 字节，指出值后面的空闲字节数。例如，如果键的值是 `America`，更新为 `USA` 后，将有 `4` 个空闲的字节。
4.  `zmend` : 总是 `255`. 指出 `zipmap` 结束。

*有效的例子*：
`18 02 06 4d 4b 44 31 47 36 01 00 32 05 59 4e 4e 58 4b 04 00 46 37 54 49 ff ..`

1.  从使用“字符串编码”开始解码。你会注意到 18 是字符串的长度。因此，我们将读取下24个字节，直到ff。
2.  现在，我们开始解析从  @02 06… @ 开始的字符串，使用 “Zipmap 编码”
3.  02是hashmap里条目的数量.
4.  06是下一个字符串的长度. 因为长度小于254, 我们不需要读取任何额外的字节
5.  我们读取下6个字节  4d 4b 44 31 47 36 来得到键 “MKD1G6”
6.  01是下一个字符串的长度，这个字符串应当是值
7.  00是空闲字节的数量
8.  读取下一个字节 0x32，得到值“2”
9.   在这种情况下，空闲字节是0，所以不需要跳过任何东西
10.  05是下一个字符串的长度，在这种情况下是键。
11.  读取下5个字节 59 4e 4e 58 4b, 得到键 “YNNXK”
12.  04是下一个字符串的长度，这是一个值
13.  00是值后面的空闲字节数
14.  读取下4个字节 46 37 54 49 来得到值 “F7TI”
15.  最终，遇到 FF, 这表示这个zipmap的结束
16. 因此，这个zipmap表示hash {"MKD1G6" => "2", "YNNXK" => "F7TI"}




## Ziplist 编码
一个 Ziplist 是一个序列化为一个字符串的 list。本质上，list 的元素按顺序地存储，借助于标记（`flag`）和偏移（`offset`）来达到高校地双向遍历 list。

为解析一个 ziplist，首先从流中读取一个字符串，按“字符串编码”。这个字符串是 ziplist 的封装。这个字符串的内容表示了 ziplist。

字符串里的 ziplist 的结构如下：<zlbytes><zltail><zllen><entry><entry><zlend>

> 1.  `zlbytes` ：这是一个 `4` 字节无符号整数，表示 ziplist 的总字节数。这 `4` 字节是 little endian 格式－－最先出现的是最低有效位组。
> 2.  `zltail`：这是一个 `4` 字节无符号整数，little endian 格式。它表示到 ziplist 的尾条目（tail entry）的偏移。
> 3.  `zllen`：这是一个 `2` 字节无符号整数，little endian 格式。它表示 ziplist 的条目的数量
> 4.  `entry`：一个条目表示 ziplist 的元素。细节在下面
> 5.  `zlend`：总是等于 `255`。它表示 ziplist 的结束

ziplist的每个条目有下面的格式：
`<length-prev-entry><special-flag><raw-bytes-of-entry>`

>  `length-prev-enty`： 这个字段存储上一个条目的长度，如果是第一个条目则是 0。这允许容易地进行反向遍历 list。这个长度存储为 1 或 5 个字节。
     如果第一个字节小于等于 253，它被认为是长度，如果第一个字节是 254，接下来 4 个字节用于存储长度。4 字节按无符号整数读取。
>  
>  `special-flag`：这个标记指出条目是字符串还是整数。它也指示字符串长度或整数的大小。这个标记的可变编码如下：
>  >  1.  |00pppppp|  － 1 字节：字符串值长度小于等于 63 字节（6 bit）
>  >  2.  |01pppppp|qqqqqqqq|  － 2 字节：字符串值长度小于等于 16383 字节（14 bit）
>  >  3.  |10______|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|  － 5 字节：字符串值长度大于等于 16384 字节
>  >  4.  |1100____|  － 读取后面 2 个字节作为 16 bit 有符号整数
>  >  5.  |1101____|  － 读取后面 4 个字节作为 32 bit 有符号整数
>  >  6.  |1110____|  － 读取后面 8 个字节作为 64 bit 有符号整数
>  >  7.  |11110000|  － 读取后面 3 个字节作为 2 4bit 有符号整数
>  >  8.  |11111110|  － 读取后面 1 个字节作为 8 bit 有符号整数
>  >  9.  |1111xxxx|  － （当 xxxx 位于 0000 到 1101）直接 4 bit 整数。0 到 12 的无符号整数。被编码的实际值是从 1 到
               13，因为 0000 和 1111 不能使用，所以应当从编码的4bit值里减去 1 来获得正确的值。
>  
>  `Raw Bytes`：在 `special flag` 后，是原始字节。字节的数字由前面的 `special flag` 部分决定。
>  
>  *举例*
`23 23 00 00 00 1e 00 00 00 04 00 00 e0 ff ff ff ff ff ff ff 7f 0a d0 ff ff 00 00 06 c0 fc 3f 04 c0 3f 00 ff ... `
  |           |           |     |                             |                 |           |           |       

>  >  1.  从使用“字符串编码”开始解码。23 是字符串的长度，然后读取35个字节直到 ff
>  >  2.  使用“Ziplist 编码”解析开始于 23 00 00  ... 的字符串
>  >  3.  前4个字节 23 00 00 00 表示Ziplis长度的字节总数。注意，这是little endian 格式
>  >  4.  接下来4个字节 1e 00 00 00 表示到尾条目的偏移。 0x1e = 30，这是一个基于0的偏移。
>  >       0th position = 23, 1st position = 00 and so on. It follows that the last entry starts at 04 c0 3f 00 .. 。
>  >  5.  接下来2个字节 04 00 表示list里条目的数量。
>  >  6.  从现在开始，读取条目。
>  >  7.  00 表示前一个条目的长度。0表示这是第一个条目。
>  >  8.  e0 是特殊标记，因为它开始于位模式 1110____，读取下8个字节作为整数。这是list的第一个条目。
>  >  9.  现在开始读取第二个条目。
>  >  10.  0a 是前一个条目的长度。10 字节 ＝ 1 字节prev长度 ＋ 1 字节特殊标记长度 ＋ 8 字节整数
>  >  11.  d0 是特殊标记，因为它开始于位模式 1101____，读取下4个字节作为整数。这是list的第二个条目。
>  >  12.  现在开始第二个条目。
>  >  13.  06 是前一个条目的长度。 6 字节 ＝ 1 字节prev长度 ＋ 1 字节特殊标记 ＋ 4 字节整数。
>  >  14.  c0 是特殊标记，因为它开始于位模式 1100____，读取下2个字节作为整数。这是list的第三个条目。
>  >  15.  现在开始读取第四个条目。
>  >  16.  04 是前一个题目的长度。
>  >  17.  c0 指出是2字节整数。
>  >  18.  读取下2个字节，作为第四个条目。
>  >  19.  最终遇到 ff，这表明已经读取完list里的所有元素。
>  >  20.  因此，ziplist存储了值  [0×7fffffffffffffff, 65535, 16380, 63]。


##  Intset 编码
一个 Inset 是一个整数的二叉搜索树。这个二叉树在一个整数数组里实现。intset 用于当 set 的所有元素都是整数时。Inset 支持达 `64` 位的整数。
作为一个优化，如果整数能用更少的字节表示，整数数组将由 `16` 位或 `32` 位整数构建。当一个新元素插入时，intset 实现在需要时将进行一次升级。

因为 Intset 是二叉搜索树，set 里的数字总是有序的。

一个 Intset 有一个 Set 的外部接口。

为了解析 Inset，首先使用“字符串编码”从流中读取一个字符串。这个字符串包含了 Intset。这个字符串的内容表示了 Intset。

在字符串里，Intset 有一个非常简单的布局： `<encoding><length-of-contents><contents>`

>  1.  `encoding`：是一个 `32` 位无符号整数。它有 3 个可能的值 － `2`, `4` 或 `8`。它指出内容里存储的每个整数的字节大小。嗯，是的，这是浪费的－可以在 `2` bit 里存储这些信息。
>       
>  2.  `length-of-contet`：是一个 `32` 位无符号整数，指出内容数组的长度。
>  
>  3.  `contents`：是一个 `$length-of-content` 个字节的数组。它包含了二叉搜索树。

*举例*
`14 04 00 00 00 03 00 00 00 fc ff 00 00 fd ff 00 00 fe ff 00 00 ...`

1.  使用“字符串编码”来开始。14 是字符串的长度，读取下 20 个字节直到 00.
2.  现在，开始解析开始于 04 00 00 .... 的字符串。
3.  前 4 个字节 04 00 00 00 是编码，因为它的值是 4，我们知道我们正在处理 32 位整数。
4.  下 4 个字节 03 00 00 00 是内容的长度。这样，我们知道我们正在处理 3 个整数，每个 4 字节长。
5.  从现在开始，我们以 4 个字节为一组读取，再把它转换为一个无符号整数。
6.  这样，我们的 intset 看起来是这样的 － 0x0000FFFC, 0x0000FFFD, 0x0000FFFE。注意，这些整数是 little endian 格式的。首先出现的是最低有效位。


## 以Ziplist 编码的 Sorted Set 
以 ziplist 编码存储的 sorted list 跟上面描述的 Ziplist 很像。在 ziplist 里，sorted set 的每个元素后跟它的 score。

*举例*   
 `[‘Manchester City’, 1, ‘Manchester United’, 2, ‘Totenham’, 3] `

如你所见 score 跟在每个元素后面。


## Ziplist编码的Hashmap
在这里，hashmap 的键值对是作为连续的条目存储在 ziplist 里。

注意：这是在 rdb 版本 4 引入，它废弃了在先前版本里使用的 zipmap。

*举例*   
` {"us" => “washington”, “india” => "delhi"} `   
存储在 ziplist 里是： ` [“us”, “washington”, “india”, “delhi”]`


### CRC32 校验和
从 RDB 版本 5 开始，一个 `8` 字节的 `CRC32` 校验和被加到文件结尾。可以通过  redis.conf 文件的一个参数来作废这个校验和。

当校验和被作废时，这个字段将是 `0`。

